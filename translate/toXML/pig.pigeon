// vim: tw=0
// Uhh
{
package toXML

import (
        "fmt"
	"strings"
        "github.com/roflcopter4/x4c/ast"
)

func toIS(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}

func doconv(lst []interface{}) string {
    buf := ""
    for _, sub := range lst {
	if sub == nil {
	    continue
	}
	switch x := sub.(type) {
	case []interface{}:
	    buf += doconv(x)
	case []byte:
	    buf += string(sub.([]byte))
	}
    }

    return buf
}



func toStr(v interface{}) string {
    if v == nil {
	panic("Invalid")
    }

    return doconv(toIS(v))
}

//type MyParser Peg {
//	depth int
//	_err error
//}
}

//===========================================================================

Document          <- _ FileTypeStatement EOF
FileTypeStatement <- XMLStatement
XMLStatement      <- XMLExpression CompoundStatement
XMLExpression
        <- Ident:Identifier LANGLE AttributeList RANGLE
            {
                // depth := (c.globalStore["depth"].(int)); fmt.Printf("%s%s\n", strings.Repeat(" ", depth*4), toStr(Ident))

                c.globalStore["cur"] = c.globalStore["block"].(ast.Node).AddXMLStatement(toStr(Ident))
                return nil, nil
            }

AttributeList <- ( Attribute )*

Attribute
        <- Ident:XPathIdentifier EQU Value:AttributeValue
            {
                switch t := c.globalStore["cur"].(type) {
                case *ast.RootNode:
                    t.AddAttribute(toStr(Ident), ast.NewExpression(toStr(Value)))

                case *ast.XMLStatement:
                    t.AddAttribute(toStr(Ident), ast.NewExpression(toStr(Value)))
                default:
                    panic("WHAT")
                }
                return nil, nil
            }

AttributeValue    <- DQUOT Value:(AttrChar*) DQUOT { return Value, nil; }

AttrChar <- !'"' . / '\\' '"'

CompoundStatement
        <- OpenBrace Statement* CloseBrace
         / SEMI

OpenBrace
	<- LCURLY
	   {
               c.globalStore["block"] = c.globalStore["cur"]

               // depth := (c.globalStore["depth"].(int))
               // fmt.Printf("%s%c\n", strings.Repeat(" ", depth*4), 123)
               // c.globalStore["depth"] = (interface{})(depth + 1)
	       return nil, nil
           } 

CloseBrace
	<- RCURLY
           {
               c.globalStore["block"] = (c.globalStore["block"].(ast.Node)).Parent()

               // depth := (c.globalStore["depth"].(int)) - 1
               // c.globalStore["depth"] = (interface{})(depth)
               // fmt.Printf("%s%c\n", strings.Repeat(" ", depth*4), 125)
	       return nil, nil
	   }

Statement
        <- XMLStatement

//===========================================================================

Keyword <- "Niggerfaggot"

Identifier      <- !Keyword IdNondigit IdChar* _
XPathIdentifier <- !Keyword IdNondigit XMLIdChar* _

IdNondigit <- [a-zA-Z_]
IdChar     <- [a-zA-Z0-9_]
XMLIdChar  <- [a-zA-Z0-9_:]

//===========================================================================
// Operators / Punctuators

LCURLY    <-  '{'          _
RCURLY    <-  '}'          _
SEMI      <-  ';'          _
LANGLE    <-  '<'  !'='    _
RANGLE    <-  '>'  !'='    _
EQU       <-  '='  !'='    _
DQUOT     <-  '"'          _

//LT <- LANGLE
//GT <- RANGLE

/* COMMA     <-  ','          _ */
//SQUOT     <-  """          _

// LBRK      <-  "["          _
// RBRK      <-  "]"          _
// LPAREN    <-  "("          _
// RPAREN    <-  ")"          _
// AMP       <-  "&"  ![&]    _
// STAR      <-  "*"  ![=]    _
// PLUS      <-  "+"  ![+=]   _
// MINUS     <-  "-"  ![\-=>] _
// TILDA     <-  "~"          _
// BANG      <-  "!"  ![=]    _
// BACKSLASH <-  "/"  ![=]    _
// PERCENT   <-  "%"  ![=>]   _
// DOT       <-  "."          _
// PTR       <-  "->"         _
// INC       <-  "++"         _
// DEC       <-  "--"         _
// LEFT      <-  "<<" ![=]    _
// RIGHT     <-  ">>" ![=]    _
// LE        <-  "<="         _
// GE        <-  ">="         _
// EQUEQU    <-  "=="         _
// BANGEQU   <-  "!="         _
// HAT       <-  "^"  ![=]    _
// OR        <-  "|"  ![=]    _
// ANDAND    <-  "&&"         _
// OROR      <-  "||"         _
// QUERY     <-  "?"          _
// COLON     <-  ":"  ![>]    _
// ELLIPSIS  <-  "..."        _
// STAREQU   <-  "*="         _
// DIVEQU    <-  "/="         _
// MODEQU    <-  "%="         _
// PLUSEQU   <-  "+="         _
// MINUSEQU  <-  "-="         _
// LEFTEQU   <-  "<<="        _
// RIGHTEQU  <-  ">>="        _
// ANDEQU    <-  "&="         _
// HATEQU    <-  "^="         _
// OREQU     <-  "|="         _


//===========================================================================

_
    <- ( Whitespace
       / Newline
       / BlockComment
       / LineComment
       )*

Whitespace   <- [ \t]
Newline      <- [\r\n]
BlockComment <- "/*" (!"*/" .)* "*/"
LineComment  <- "//" (!"\n" .)*

EOF <- !.

// vim: set tw=0
